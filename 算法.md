## 说说你对算法的理解？应用场景？

一个程序=算法+数据结构，数据结构是算法实现的基础，算法总是要依赖于某种数据结构来实现的，两者不可分割。
因此，算法的设计和选择要同时结合数据结构，简单地说数据结构的设计就是选择存储方式，如确定问题中的信息是用数组存储还是用普通的变量存储或其他更加复杂的数据结构。

算法:是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别

衡量不同算法之间的优劣主要是通过时间和空间两个维度去考量：

时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述
通常会遇到一种情况，时间和空间维度不能够兼顾，需要在两者之间取得一个平衡点是我们需要考虑的

一个算法通常存在最好、平均、最坏三种情况，我们一般关注的是最坏情况
最坏情况是算法运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，也意味着平均情况和最坏情况一样差

数据结构是计算机存储、组织数据的方式，是指相互之间存在一种或多种特定关系的数据元素的集合
前面讲到，一个程序 = 算法 + 数据结构，数据结构是实现算法的基础，选择合适的数据结构可以带来更高的运行或者存储效率

线性结构有：数组、栈、队列、链表等
非线性结构有：树、图、堆等

`LRU 缓存的基本原理`
缓存容量：LRU 缓存有一个固定的容量，当缓存已满时，必须淘汰一些数据才能插入新数据。
淘汰策略：LRU 缓存通过跟踪每个数据的访问时间，来决定哪些数据最少被使用。每当一个数据被访问时，该数据被认为是最近使用的。缓存满了之后，最久未被访问的数据会被移除，以腾出空间。
数据结构：LRU 缓存通常使用一个双向链表和一个哈希表来实现。哈希表用于在 O(1)时间内快速查找数据，双向链表用于记录数据的使用顺序，链表头部存放最新使用的数据，尾部存放最久未使用的数据。

访问数据：每次访问缓存中的数据时，都会将该数据移动到双向链表的头部，表示它是最近使用的。
插入数据：当插入新的数据时，如果缓存未满，直接将数据插入到链表头部；如果缓存已满，则移除链表尾部的数据，然后将新数据插入到头部。
删除数据：如果缓存需要腾出空间，则移除链表尾部的数据（即最久未使用的数据）

class LRUCache {
constructor(capacity) {
this.capacity = capacity;
this.cache = new Map();
}

    get(key) {
        if (!this.cache.has(key)) {
            return -1;
        }
        // 访问数据，将其移动到最新位置
        const value = this.cache.get(key);
        this.cache.delete(key);
        this.cache.set(key, value);
        return value;
    }

    put(key, value) {
        if (this.cache.has(key)) {
            this.cache.delete(key);
        } else if (this.cache.size >= this.capacity) {
            // 缓存已满，删除最久未使用的元素
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        // 插入新元素
        this.cache.set(key, value);
    }

}

// 使用示例
const lru = new LRUCache(3);
lru.put(1, 1);
lru.put(2, 2);
lru.put(3, 3);
console.log(lru.get(1)); // 输出: 1
lru.put(4, 4); // 移除 key 2
console.log(lru.get(2)); // 输出: -1 (key 2 已被移除)

集合（set）：确定性（可以判断元素是否存在）、无序性（只要元素完全相同就判断是相同集合）、互异性（集合里面的元素各不相同）
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);
let intersect = new Set([...a].filter(x => b.has(x)));//交集
let union = new Set([...a, ...b]); //并集

树：前序、中序、后序、层序遍历
堆：完全二叉树，大顶堆和小顶堆：插入和删除时间复杂度都是 Olog(n)

贪心选择：当某一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次做出的选择可以依赖以前做出的选择，但不需要依赖后面需要做出的选择

