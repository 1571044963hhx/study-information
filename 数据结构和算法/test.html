<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //冒泡排序
        let arr = [1, 3, 3, 5, 7, 7, 9, 13, 13, 45, 88]
        function sort(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                let flag = false
                for (let j = 0; j < i; j++) {
                    //原地排序，在i索引后面的元素已经排好序了
                    if (arr[j] > arr[j + 1]) {
                        let tmp = arr[j]
                        arr[j] = arr[j + 1]
                        arr[j + 1] = tmp
                        flag = true
                    }
                }
                //可以将最佳时间复杂度提到O(n)
                if (!flag) break
            }
        }
        //选择排序
        function sort1(arr) {
            let n = arr.length
            for (let i = 0; i < n; i++) {
                let k = i
                for (let j = i + 1; j < n; j++) {
                    if (arr[j] < arr[k]) {
                        k = j
                    }
                }
                //将该最小元素与未排序区间的首个元素交换(不稳定排序)
                [arr[i], arr[k]] = [arr[k], arr[i]]
            }
        }
        //插入排序
        function sort2() {
            for (let i = 1; i < arr.length; i++) {
                
                let base = arr[i], j = i - 1
                //内循环，将base插入到已经排序区间[0,i-1]中的正确位置
                while (j >= 0 && arr[j] > base) {
                    //我们需要将从目标索引到 base 之间的所有元素向右移动一位，然后将 base 赋值给目标索引。
                    arr[j + 1] = arr[j]
                    j--
                }
                arr[j + 1] = base
            }
        }
        let arr1 = [4, 1, 3, 4, 8, 6, 5, 7, 2, 3, 6]
        //快速排序
        function quickSort(array) {
            // 基本情况：如果数组为空或只有一个元素，则返回数组
            if (array.length <= 1) {
                return array;
            }
            // 选择基准
            const pivot = array[Math.floor(array.length / 2)];
            // 定义左右数组
            let left = [];
            let right = [];
            // 遍历数组，将元素放入左右数组中
            for (let i = 0; i < array.length; i++) {
                if (i !== Math.floor(array.length / 2)) { // 跳过基准元素
                    if (array[i] < pivot) {
                        left.push(array[i]);
                    } else {
                        right.push(array[i]);
                    }
                }
            }
            // 递归排序并合并结果
            return [...quickSort(left), pivot, ...quickSort(right)];
        }

        //归并排序
        function mergeSort(array) {
            // 基本情况：如果数组只有一个元素或为空，则直接返回数组
            if (array.length <= 1) {
                return array;
            }

            // 将数组分成两半
            const mid = Math.floor(array.length / 2);
            const left = array.slice(0, mid);
            const right = array.slice(mid);

            // 递归地对两半进行排序并合并
            return merge(mergeSort(left), mergeSort(right));
        }
        //合并两个有序数组
        function merge(left, right) {
            let result = [];
            let i = 0;
            let j = 0;
            // 交替取出两个数组中较小的元素，直到其中一个数组为空
            while (i < left.length && j < right.length) {
                if (left[i] < right[j]) {
                    result.push(left[i]);
                    i++;
                } else if (left[i] > right[j]) {
                    result.push(right[j]);
                    j++;
                } else {
                    result.push(left[i], right[j])
                    i++;
                    j++
                }
            }
            // 将剩余的元素添加到结果数组中
            return result.concat(left.slice(i)).concat(right.slice(j));
        }

        let nums = [3, 30, 34, 5, 9]
        var largestNumber = function (nums) {
            nums.sort((a, b) => {
                var stra = b.toString() + a.toString(), strb = a.toString() + b.toString();
                console.log(stra, strb)
                if (stra > strb) {
                    return 1
                } else {
                    return -1
                }
            });
            if (nums[0] == 0) return '0'
            return nums.join('');
        };
        largestNumber(nums)
        console.log(largestNumber(nums))

        let nums1 = [1,2,3,2,1]
        var largestNumber = function (nums) {
            nums.sort((a, b) => {
                var stra = b.toString() + a.toString(), strb = a.toString() + b.toString();
                console.log(stra, strb)
                if (stra > strb) {
                    return 1  // 如果 b+a 比 a+b 大，则 b 应该排在 a 前面
                } else {
                    return -1  // 如果 a+b 比 b+a 大，则 a 应该排在 b 前面
                }
            });
            console.log(nums)
            if (nums[0] == 0) return '0'
            return nums.join('');
        };
        largestNumber(nums)
        console.log(largestNumber(nums))

        
    </script>
</body>

</html>