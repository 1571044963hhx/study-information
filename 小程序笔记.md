## 尚硅谷小程序基础课程笔记

## 一、小程序基础

1、基本概念
微信基础库：是指小程序的运行环境，给小程序提供了运行所需的各种 API 和工具，以及基础框架和运行逻辑等。（在本地设置中选择）

2、配置文件介绍（页面的配置项会覆盖全局的配置项）

1. app.json：小程序全局配置文件，用于配置小程序的一些全局属性和页面路由。（路由，tabbar,注册全局使用组件，分包，预下载等等）
2. 页面.json：小程序页面配置文件，也称局部配置文件，用于配置当前页面的窗口样式、页面标题等
3. project.config.json：小程序项目的配置文件，用于保存项目的一些配置信息和开发者的个人设置（比如在里面设置 scss，es6 的使用环境，appid）
4. sitemap.json：配置小程序及其页面是否允许被微信索引，提高小程序在搜索引擎搜索到的概率

project.config.json ：项目配置文件，常用来进行配置公共的配置
project.private.config.json ：项目私有的配置，常用来配置个人的配置

1. project.private.config.json 写到 .gitignore 避免版本管理的冲突。
2. 与最终编译结果有关的设置必须设置到 project.config.json 中

pages 字段：用来指定小程序由哪些页面组成，用于让小程序知道由哪些页面组成以及页面定义在哪个目录，每一项都对应一个页面的路径信息。entryPagePath 用于设置首页。
tabBar 字段：定义小程序顶部、底部 tab 栏，用以实现页面之间的快速切换（最少两个，最多五个）

## 二、小程序样式和组件介绍

小程序提供了 WXML 进行页面结构编写，同时提供了 WXSS 进行页面的样式编写
在小程序中不能使用 HTML 标签，也就没有 DOM 和 BOM，CSS 也仅仅支持部分选择器。WXML 提供了 view、text、image、navigator 等标签来构建页面结构，只不过在小程序中将标签称为组件
WXSS 对 CSS 扩充和修改，新增了尺寸单位 rpx、提供了全局的样式和局部样式，另外需要注意的是 WXSS 仅支持部分 CSS 选择器

`rpx: 是小程序新增的自适应单位，它可以根据不同设备的屏幕宽度进行自适应缩放，小程序规定任何型号手机：屏幕宽都为 750 rpx。`
`一般设计采用 ipone6 作为标准，它的手机宽度为 375px，正好为 750 的一半，方便后续的计算。`

小程序常用组件：

```1、视图容器组件（移动，滚动，滑动，普通视图容器）
movable-area：可移动的区域
movable-view：可移动的视图容器，在页面中可以拖拽滑动。movable-view必须在movable-area组件中，并且必须是直接子节点，否则不能移动。
scroll-view：可滚动视图区域（可以在里面放置多个view容器）。使用竖向滚动时，需要给scroll-view一个固定高度，通过 WXSS 设置 height。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)。
swiper：滑块视图容器。其中只可放置swiper-item（swiper-item：仅可放置在swiper组件中，宽高自动设置为100%。）组件，否则会导致未定义的行为。
view：视图容器
```

```2、基础内容组件
1、icon
2、progress
3、rich-text：这个可以嵌套一些其它东西
4、text：text 组件内只支持 text 嵌套  textarea:多行输入框。该组件是原生组件，使用时请注意相关限制。
```

```3、表单组件
1、button
2、checkbox(多选)  checkbox-group：多项选择器，内部由多个checkbox组成。 radio：单选   radio-group：单项选择器，内部由多个 radio 组成
3、editor：富文本编辑器，可以对图片、文字进行编辑。
4、form：表单。将组件内的用户输入的switch input checkbox slider radio picker 提交。
当点击 form 表单中 form-type 为 submit 的 button 组件时，会将表单组件中的 value 值进行提交，需要在表单组件中加上 name 来作为 key。
5、input
6、label
7、picker：从底部弹起的滚动选择器（time,date,region,用过日期和地区的选择器。
8、picker-view：用于包裹picker-view-column组件，可以理解为自定义滚动选择器
9、slider:滑动选择器。
10、switch：开关选择器。
```

## 面试题三：说说微信小程序中路由跳转的方式有哪些？区别？

```4、其它组件
1、navigator：
wx.navigateTo()：保留当前页面，跳转到应用内的某个页面，但是不能跳到tabbar 页面                               navigate
wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到tabbar页面                            redirect
wx.switchTab()：跳转到tabBar 页面，路径后不能带参数(tabBar 页面之间相互切换，页面不会被销毁)                 switchTab：不支持传递参数，并关闭其他所有非 tabBar 页面
wx.reLaunch()：关闭所有页面，打开到应用内的某个页面                                                        reLaunch
wx.navigateBack()：关闭当前页面，返回上一页面或多级页                                                      navigateBack   navigator  open-type  exit  退出当前程序。
navigateTo 新页面入栈
redirectTo 当前页面出栈，新页面入栈
navigateBack 页面不断出栈，直到目标返回页，新页面入栈
switchTab 页面全部出栈，只留下新的 Tab 页面
reLanch 页面全部出栈，只留下新的页面

2、image：图片组件  注意：小程序的 background-image 不支持本地路径 ！需要使用网络图片，或者 base64，或者使用 <image /> 组件
3、video:视频
4、audio：音频
```

## 面试题一：说说你对微信小程序的理解？优缺点？
小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用
也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载
注意的是，除了微信小程序，还有百度小程序、微信小程序、支付宝小程序、抖音小程序，都是每个平台自己开发的，都是有针对性平台的应用程序

优点：
随搜随用（不用下载），用完即走（不用卸载）：使得小程序可以代替许多 APP，或是做 APP 的整体嫁接，或是作为阉割版功能的承载体
流量大，易接受：小程序借助自身平台更加容易引入更多的流量
安全
开发门槛低
降低兼容性限制

缺点：
用户留存：及相关数据显示，小程序的平均次日留存在 13%左右，但是双周留存骤降到仅有 1%
体积限制：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序
受控微信：比起 APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控

## 三、事件系统
事件分为 冒泡事件 和 非冒泡事件：
非冒泡事件：当一个组件的事件被触发后，该事件不会向父节点传递

冒泡事件：当一个组件的事件被触发后，该事件会向父节点传递
使用 bind 绑定的事件，会触发事件冒泡，如果想阻止事件冒泡，可以使用 catch 来绑定事件。

在组件上 通过 data-_ 的方式 定义需要传递的数据，其中 _ 是自定义的属性，例如：<view data-id=“100” bindtap=“handler” />然后通过事件对象进行获取自定义数据。

1. event.target 是指事件触发者， event.currentTarget 是指事件绑定者（此处涉及事件代理）
2. 使用 data- 方法传递参数的时候，多个单词由连字符 - 连接，连字符写法会转换成驼峰写法
3. 使用 data- 方法传递参数的时候，而大写字符会自动转成小写字符

在组件上使用 mark:自定义属性 的方式将数据传递给事件处理函数，例如：<view mark:id=“100” bindtap=“handler” />

mark 包含从触发事件的节点到根节点上所有的 mark: 属性值（有点类似冒泡）
currentTarget.dataset 或者 target.dataset 只包含事件绑定者 或者 事件触发者那一个节点的 data-\* 值

�� 注意事项：简易双向绑定的属性值如下限制：

1. 只能是一个单一字段的绑定，例如：错误用法：<input model:value="值为 {{value}}" />
2. 尚不能写 data 路径，也就是不支持数组和对象，例如：错误用法：<input model:value="{{ a.b }}" />

在组件上使用 wx:for 属性绑定一个数组或对象，既可使用每一项数据重复渲染当前组件
每一项的变量名默认为 item，下标变量名默认为 index

在使用 wx:for 进行遍历的时候，建议加上 wx:key 属性， wx:key 的值以两种形式提供：

1. 字符串：代表需要遍历的 array 中 item 的某个属性，该属性的值需要是列表中唯一的字符串或数字，且不能动态改变
2. 保留关键字 \*this 代表在 for 循环中的 item 本身，当 item 本身是一个唯一的字符串或者数字时可以使用

注意：在给 wx:key 添加属性值的时候，不需要使用双大括号语法，直接使用遍历的 array 中 item 的某个属性

wx:if 和 hidden 二者的区别：（回流和重绘）

1. wx:if ：当条件为 true 时将结构展示出来，否则结构不会进行展示，通过 移除/新增节点 的方式来实现
2. hidden ：当条件为 true 时会将结构隐藏，否则结构会展示出来，通过 display 样式属性 来实现的



## 四、生命周期(一堆会在特定时期执行的函数) ## 面试题二：说说微信小程序的生命周期函数有哪些？
小程序的生命周期：（应用，页面，组件）
生命周期函数（钩子函数）：
应用生命周期：必须在 app.js 中定义 App({})
1、onlaunch()：小程序初始化，进入小程序时启动。冷启动时触发，热启动时不触发
2、onshow()：热冷启动时触发，从后台切前台
3、onHide()：从前台切后台
(onError:小程序发生脚本错误或 API 调用报错时触发,onPageNotFound:小程序要打开的页面不存在时触发)

页面生命周期：需要在 page()方法中定义，每一个页面都是通过栈来存储。
onload：初次加载时：只能调用一次,发送请求获取数据。`该生命周期中获取跳转参数`
onshow:开始渲染时，请求数据。
onready：渲染完成时，可以进行交互了。当保留当前页面进行跳转时，onhide 调用，当返回该界面时，onshow 调用。只能调用一次
onunload:页面的销毁：只能调用一次
onhide:页面的隐藏
注意：tabbar 页面之间的相互切换，页面不会销毁。
点击左上角的返回功能时，会销毁当前界面。

组件生命周期，需要在 lifetimes 字段内进行声明；
created 组件实例创建完毕（在里面不能使用 this.setData），在里面添加自定义属性 this.test = "ceshi"
attached 模板解析完成挂载到页面,一般页面的交互在里面进行。
ready 监听页面初次渲染完成
moved 监听页面隐藏
detached 组件销毁
error 每当组件方法抛出错误时执行

```
组件还有一些特殊的生命周期，这类生命周期和组件没有很强的关联
主要用于组件内部监听父组件的展示、隐藏状态，从而方便组件内部执行一些业务逻辑的处理
组件所在页面的生命周期有 4 个： show、 hide、 resize、 routeDone，需要在 `pageLifetimes` 字段内进行声明
Component({
  pageLifetimes: {
    show: function() {
      // 页面被展示
    },
    hide: function() {
      // 页面被隐藏
    },
  }
})
```

`组件所在页面的生命周期：在组件中定义`
在 pageLifeTimes show() hide(),后台切前台，组件所在的页面展示，前台切后台（组件所在的页面隐藏）

总结：应用（整个小程序）、页面（某一个界面）、组件（自定义组件）生命周期
onLaunch()1 最先执行，onshow()2 其次。整个小程序挂载完之后再考虑其它生命周期。
注意：在页面创建之前，组件先于页面创建，onload5 onshow6 onready8
created3 attached4 ready7
当关闭当前页面时，uounload1 detached2 onload3 组件后于页面销毁
当切换前后台是，类似，小程序页面先隐藏（切后台），应用先展示 onshow() 先进后出原则

小程序更新机制：启动时同步更新（当前使用为新版本），启动时异步更新（当前使用的是旧版本，下次启动为新版本）

## 面试题四：说说提高微信小程序的应用速度的手段有哪些？
小程序首次启动前，微信会在小程序启动前为小程序准备好通用的运行环境，如运行中的线程和一些基础库的初始化，然后才开始进入启动状态，
展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：
1、下载小程序代码包
2、加载小程序代码包
3、初始化小程序首页

加载
提升体验最直接的方法是控制小程序包的大小，常见手段有如下：
1、代码包的体积压缩可以通过勾选开发者工具中“上传代码时，压缩代码”选项
2、及时清理无用的代码和资源文件
3、减少资源包中的图片等资源的数量和大小（理论上除了小 icon，其他图片资源从网络下载），图片资源压缩率有限
4、并且可以采取分包加载的操作，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载
5、当用户点击到子包的目录时，还是有一个代码包下载的过程，这会感觉到明显的卡顿，所以子包也不建议拆的太大，当然我们可以采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包

关于微信小程序首屏渲染优化的手段如下：
1、请求可以在页面 onLoad 就加载，不需要等页面 ready 后在异步请求数据
2、尽量减少不必要的 https 请求，可使用 getStorageSync() 及 setStorageSync() 方法将数据存储在本地
3、可以在前置页面将一些有用的字段带到当前页，进行首次渲染（列表页的某些数据--> 详情页），没有数据的模块可以进行骨架屏的占位
4、在微信小程序中，提高页面的多次渲染效率主要在于正确使用 setData：
5、不要过于频繁调用 setData，应考虑将多次 setData 合并成一次 setData 调用
6、数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用 setData 来设置这些数据
7、与界面渲染无关的数据最好不要设置在 data 中，可以考虑设置在 page 对象的其他字段下
除此之外，对于一些独立的模块我们尽可能抽离出来，这是因为自定义组件的更新并不会影响页面上其他元素的更新

各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData 调用

三、总结
小程序启动加载性能：
控制代码包的大小
分包加载
首屏体验（预请求，利用缓存，避免白屏，及时反馈）

小程序渲染性能：
避免不当的使用 setData
使用自定义组件

## 五、API 介绍
```总共分为三种API，同步、异步和监听事件API
异步API 支持callback & Promise 两种调用方式：
1、当接口参数中不包含success,fail,complete时默认返回promise
2、部分接口，如request,uploadfile，downloadFile, connectSocket, createCamera（小游戏）本身就有返回值，因此不支持promise风格调用方式，需要自行封装。
3、当没有回调参数时，异步接口返回 promise。此时若函数调用失败进入 fail 逻辑， 会报错提示 Uncaught (in promise)，开发者可通过 catch 来进行捕获。
4、wx.onUnhandledRejection 可以监听未处理的 Promise 拒绝事件。
```

API
wx.showModal:模态对话框
wx.showLoading:显示 loading 提示框。需主动调用 wx.hideLoading 才能关闭提示框
wx.showToast:消息提示框,wx.showToast 应与 wx.hideToast 配对使用。
wx.showLoading 和 wx.showToast 同时只能显示一个
wx.startPullDownRefresh：开始下拉刷新。调用后触发下拉刷新动画，效果与用户手动下拉刷新一致。
wx.stopPullDownRefresh ：关闭下拉刷新
onReachBottom(){}：事件监听函数,上拉刷新
onPullDownRefresh(){}：下拉刷新
onShareAppMessage：用户点击右上角分享，发送给朋友
onShareTimeline，分享到朋友圈

wx.request：发起 HTTPS 网络请求。
wx.request 请求的域名必须在微信公众平台进行配置，如果使用 wx.request 请求未配置的域名，在控制台会有相应的报错。

wx.downloadFile：下载文件资源到本地。客户端直接发起一个 HTTPS GET 请求，返回文件的本地临时路径 (本地路径)，单次下载允许的最大文件为 200MB。
wx.uploadFile：将本地资源上传到服务器。客户端发起一个 HTTPS POST 请求，其中 content-type 为 multipart/form-data。
wx.requestPayment：发起微信支付。调用前需在小程序微信公众平台 -功能-微信支付入口申请接入微信支付。

wx.setStorageSync
wx.setStorage
wx.removeStorageSync
wx.removeStorage
wx.getStorageSync
wx.getStorage
wx.clearStorageSync
wx.clearStorage 注意：此处的存储并不需要将数据转为 json 格式。

wx.previewImage：预览图片
wx.chooseLocation：选择地理位置
wx.getLocation：获取当前地理位置

wx.login：调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户在当前小程序的唯一标识（openid）、微信开放平台账号下的唯一标识
（unionid，若当前小程序已绑定到微信开放平台账号）及本次登录的会话密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成

wx.authorize：向用户发起授权请求
wx.openSetting：调起客户端小程序设置界面，返回用户设置的操作结果。设置界面只会出现小程序已经向用户请求过的权限
wx.getSetting：获取用户的当前设置。返回值中只会出现小程序已经向用户请求过的权限。

## 六、自定义组件

自定义组件：
使用 component 定义
data:
method:
properites:组件对外属性，主要用来接收组件使用者对组件传递的一些数据，可以直接作为 data 使用

理解插槽：默认和具名插槽，

1.app.wxss 或页面的 wxss 中使用了标签名（view）选择器（或一些其他特殊选择器）来直接指定样式这些选择器会影响到页面和全部组件，通常情况下这是不推荐的做法。
2、组件和引用组件的页面不能使用 id 选择器，属性选择器和标签名选择器，请改用 class 选择器。

一般来说，组件自身的样式和组件使用者的样式互不干扰，有时候我们需要页面的样式对组件生效，需要关闭组件样式隔离
styleIsolation：isolated(互不影响),apply-shared(页面对组件生效),shared(两者相互影响)

可以使用 Component({})构造页面，但对应的 json 文件需要包含 usingComponents 定义字段，这个方法更为强大，比如多了监听属性和计算属性。

## 七、小程序通信
1、 获取组件的数据
this.triggerEvent('myevent', this.data.num)
<custom05 bind:myevent="getData" />
getData(event){}数据在 event 对象里面，
或者在组件使用页面上定义一个 class 属性，this.selectComponent()获取子组件实例。例如 this.selectComponent(".my-component")
2、组件使用者给组件发送数据
<custom05 data="tiancai"/> 子组件在 properties 中接受即可
3、代码复用：可以注册全局组件和页面组件

```
4、使用behavior，需要借助 `Behavior()` 方法，接受一个 `Object` 类型的参数，导出behavior.js文件。const myBehavior = require('my-behavior')导入，behaviors: [myBehavior]使用
注意事项：
. 如果有同名的属性或方法，采用 “就近原则”，组件会覆盖 behavior 中的同名属性或方法
. 如果有同名的数据字段且都是对象类型，会进行对象合并，其余情况会 采用 “就近原则” 进行数据覆盖
. 生命周期函数和 observers 不会相互覆盖，会是在对应触发时机被逐个调用，也就是都会被执行
```
5、页面间通信
1. 在 `wx.navigateTo` 的 `success` 回调中通过 `EventChannel` 对象发射事件
2. 被打开的页面可以通过 `this.getOpenerEventChannel()` 方法获得一个 `EventChannel` 对象，进行监听、发射事件
3. `wx.navigateTo` 方法中可以定义 `events` 配置项接收被打开页面发射的事件
就是发送事件对象和数据，emit发送,on监听。

6、获取应用实例：`getApp()`                 获取全局数据
7、事件总线：`pubsub-js`                   发布订阅模式
8、mobx-miniprogram 状态管理库：使用 `mobx-miniprogram` 定义管理的状态是响应式的，当状态一旦它改变，所有关联组件都会自动更新相对应的数据
1. `observable`：用于创建一个被监测的对象，对象的属性就是应用的状态(state)，这些状态会被转换成响应式数据。
2. `action`：用于修改状态(state)的方法，需要使用 action 函数显式的声明创建。
3. `computed`：根据已有状态(state)生成的新值。计算属性是一个方法，在方法前面必须加上 `get` 修饰符
总共有两种使用方式，ComponentWithStore,BehaviorWithStore(需要新建一个js文件，使用这个方法生成一个behavior)
9、插槽

## 八、vant-weapp 的样式使用

默认情况下，组件和组件使用者之间如果存在相同的类名不会相互影响，组件使用者如果想修改组件的样式，需要就解除样式隔离，
但是解除样式隔离以后，在极端情况下，会产生样式冲突、CSS 嵌套太深等问题，从而给我们的开发带来一定的麻烦。
**外部样式类：在使用组件时，组件使用者可以给组件传入 CSS 类名，通过传入的类名修改组件的样式。**

Vant Weapp 基于微信小程序的机制，为开发者提供了以下 3 种修改组件样式的方法
1、解除样式隔离（Vant Weapp 的所有组件都开启了 addGlobalClass: true 以接受外部样式的影响，可以使用如下 2 种方式覆盖组件样式）
  在页面中使用 Vant Weapp 组件时，可直接在页面的样式文件中覆盖样式
  在自定义组件中使用 Vant Weapp 组件时，需开启 styleIsolation: 'shared'选项
2、使用外部样式类（需要注意的是普通样式类和外部样式类的优先级是未定义的，因此使用时请添加!important 以保证外部样式类的优先级。）
3、Vant Weapp 为部分 CSS 属性开放了基于 CSS 属性的定制方案。相较于解除样式隔离和使用外部样式类，
这种方案支持在页面或应用级别对多个组件的样式做批量修改以进行主题样式的定制。
/_ 声明全局的变量，可在项目中任意组件中使用 _/
page {
--main-bg-color: lightcoral;
}
/_ 只有被当前类名容器包裹住的元素，使用该变量才生效 _/
.container {
--main-bg-color: lightseagreen;
}


## 面试题五、微信小程序的登录功能
实现小程序用户体系主要涉及到openid和code的概念：

调用wx.login()方法会生成code(登录凭证)，将code作为参数传递给微信服务器指定接口，就可以获取用户的openid
对于每个小程序，微信都会将用户的微信ID映射出一个小程序openid，作为这个用户在这个小程序的唯一标识。

总共七步：（客户端，公司服务器，微信服务器）
1.调用wx.login()方法会生成code(临时登录凭证，有效期五分钟)，
2.使用wx.request()将code作为参数传递给开发者服务器指定接口
3.开发者服务器将code和从微信公众平台拿到的appid和appscrect发送给微信服务器来换取openid,session_key
session_key：（微信服务器给开发者服务器颁发的唯一标识）
openid：微信都会将用户的微信ID映射出一个小程序openid，作为这个用户在这个小程序的唯一标识，可以用来区分不同的用户
4.开发者服务器拿到这些数据之后会进行一些业务逻辑的处理，比如信息加密等，生成自定义登录态。可以理解为token
5.客户端接收token并进行存储
6.客户端每次发送请求都需要在请求头中携带token
7.开发者服务器验证token，实质就是验证里面的openid和session_key，验证通过就返回数据。
实际业务中，我们还需要登录态是否过期，通常的做法是在登录态（wx.checkSession()验证），返回true直接登录成功，否则调用wx.login
在拿到token之前，可以检查用户是否授权了个人信息并且获取个人信息wx.getSettings,wx.getUserInfo

## 面试题六、说说微信小程序的发布流程
上传代码:微信开发者工具中点击上传，填写版本信息等
提交审核：微信小程序客户端-开发管理-提交审核
发布版本：审核通过即可提交发布版本

上述是最简单的小程序代码发布的流程，通常的流程如下：
代码管理服务器上新建分支
开发测试新需求
测试完成后，将本地分支合并到 master 分支
拉取 master 分支最新代码，执行 build 命令生成小程序可执行文件
开发者工具点击“上传”
提审
发布

## 面试题七、微信小程序的支付流程
打开某小程序，点击直接下单
wx.login获取用户临时登录凭证code，发送到后端服务器换取openId
1.在下单时，小程序需要将购买的商品Id，商品数量，以及用户的openId传送到服务器
2.服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息
3.前端在获取对应的参数（预付单信息）后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付
4.接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付
5.鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示
6.推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态

## 面试题八、微信小程序的实现原理
一、背景
网页开发，渲染线程和脚本是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应的原因，本质就是我们常说的 JS 是单线程的
而在小程序中，选择了 Hybrid 的渲染方式，将`视图层和逻辑层`是分开的，`双线程`同时运行，
视图层的界面使用 WebView 进行渲染，逻辑层运行在 JSCore 中

渲染层：`界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程`
逻辑层：`采用 JsCore 线程运行 JS 脚本，在这个环境下执行的都是有关小程序业务逻辑的代码`

二、通信
小程序在渲染层，宿主环境会把wxml转化成对应的JS对象
`在逻辑层发生数据变更的时候，通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层`
`再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的视图`

当视图存在交互的时候，例如用户点击你界面上某个按钮，这类反馈应该通知给开发者的逻辑层，需要将对应的处理状态呈现给用户
对于事件的分发处理，微信进行了特殊的处理，将所有的事件拦截后，丢到逻辑层交给JavaScript进行处理

由于小程序是基于双线程的，也就是任何在视图层和逻辑层之间的数据传递都是线程间的通信，
会有一定的延时，因此在小程序中，页面更新成了异步操作
异步会使得各部分的运行时序变得复杂一些，比如在渲染首屏的时候，逻辑层与渲染层会同时开始初始化工作，
但是渲染层需要有逻辑层的数据才能把界面渲染出来
如果渲染层初始化工作较快完成，就要等逻辑层的指令才能进行下一步工作
因此逻辑层与渲染层需要有一定的机制保证时序正确，在每个小程序页面的生命周期中，存在着若干次页面数据通信

三、运行机制
小程序启动运行两种情况：

冷启动（重新开始）：用户首次打开或者小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即为冷启动
热启动：用户已经打开过小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需要将后台态的小程序切换到前台，这个过程就是热启动

注意：
1.小程序没有重启的概念
2.当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后会被微信主动销毁
3.短时间内收到系统两次以上内存警告，也会对小程序进行销毁，这也就为什么一旦页面内存溢出，页面会奔溃的本质原因了

这里需要补充一个同步更新和异步更新的概念

## 写小程序中使用到的包，有什么作用？
async-validator：验证   import Schema from 'async-validator'
"mobx-miniprogram"  "mobx-miniprogram-bindings"  状态管理库  "miniprogram-computed" 计算和监视属性
licia  防抖处理

## 小程序的难点
loading封装的问题：
1.当我发起并发请求时，会弹起多个loading，但后面的会把前面的给覆盖，因此只显示一个loading，会造成资源浪费。
2.当有一个请求结束后，就会立即关闭loading，这时可能还有一些请求没有完成
3.当一个请求依赖于另一个请求时，当第一个请求结束后关闭loading，并立即启动新的loading，会造成loading闪烁问题。

在类中新增一个实例属性quene，初始值为一个空数组，在发起请求时，如果是空数组则显示loading，并添加一个request标识，
当请求完成后，删除一个request，当quene中不存在request则关闭loading。

清除定时器->判断是否为空（展示loading）-添加request标识（1个）-删除request标识（0个）-判断是否为空（添加request标识，1个）
如果没有连续依赖的请求：-定时器（删除request标识（0个）-判断是否为空（隐藏loading））
如果请求连续：第二个请求清除第一个请求的定时器，不为空（不展示loading）-再添加加request标识（2个）-删除request标识（1个）
-不为空（不添加request标识，1个）-走定时器（删除request标识-为空（隐藏loading））

## 总结收获
1. 小程序内置组件：采用小程序内置组件并结合 `Vant` 组件库实现页面结构的搭建
2. 项目中使用了 css 拓展语言 Scss 绘制页面的结构
3. 小程序内置`API`：交互、支付、文件上传、地图定位、网络请求、预览图片、本地存储等
4. 小程序分包加载：降低小程序的启动时间、包的体积，提升用户体验度
5. 小程序组件开发：将页面内的功能模块抽象成自定义组件，实现代码的复用
6. 网络请求封装：request 方法封装、快捷方式封装、响应拦截器、请求拦截器
7. `骨架屏`组件：利用开发者工具提供了自动生成骨架屏代码的能力，提高了整体使用体验和用户满意度。
8. `UI` 组件库：使用 `Vant` 组件库实现小程序 结构的绘制
9. `LBS`：使用腾讯地图服务进行 `LBS`逆地址解析，实现选择收货地址功能
10. `miniprogram-licia`：使用 [licia](https://licia.liriliri.io/) 进行函数的防抖节流
11. `async-validator`：使用 [async-validator](https://github.com/yiminghe/async-validator) 实现表单验证
12. `miniprogram-computed`: 使用 [miniprogram-computed](https://github.com/wechat-miniprogram/computed)  进行计算属性功能
13. `mobx-miniprogram`：使用 `mobx-miniprogram` 进行项目状态的管理
```补充
`wx.chooseLocation()`返回的数据并没有包含省市区、省市区编码数据。而新增收货地址接口，需要传递省市区、省市区编码数据。因此需要进行逆地址解析
打包原则：
1. tabBar 页面必须在主包内
2. 最外层的 pages 字段，属于主包的包含的页面
3. 按 subpackages 配置路径进行打包，配置路径外的目录将被打包到主包中
4. 分包之间不能相互嵌套，subpackage 的根目录不能是另外一个 subpackage 内的子目录

引用原则：

1. 主包不可以引用分包的资源，但分包可以使用主包的公共资源
2. 分包与分包之间资源无法相互引用， 分包异步化时不受此条限制

独立分包：独立分包是小程序中一种特殊类型的分包，可以**独立于主包和其他分包运行**。
```